# 维塑工作总结

# 大概介绍

公司主要的产品是做智能体测仪。

然后分为多个产品线：

vd, vd-pro3, ve, va。

每个产品分别包含：设备端，公众号，b端管理平台，后台sass，flutter写的app

# 设备端

设备端端环境是个linux环境，上面有一个electron应用，并且还部署一些算法服务，例如：使用opencv写的体态识别，还有一些硬件服务，例如：检测人是否站立在转台上面。还有使用go写的一个中间层的控制服务

期间通信一开始是socket进行通信，后期在做版本重构的时候，使用了grpc进行通信

[https://zhuanlan.zhihu.com/p/377860784](https://zhuanlan.zhihu.com/p/377860784)

gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。

[https://blog.csdn.net/weixin_40580582/article/details/118661409](https://blog.csdn.net/weixin_40580582/article/details/118661409)

# b端管理平台

这里使用了乾坤框架用来做微服务，其中关于支付页面属于一个子应用

[https://qiankun.umijs.org/zh/guide](https://qiankun.umijs.org/zh/guide)

其中包含一个打印报告的页面，其中包含例如：身体成分报告打印，体态打印

这里使用了iframe嵌套了打印报告页面，并且在后端使用了selenium，一个无头浏览器

# 后台sass

这就是一个管理用户，公司的平台，用来创建账号这些服务

# 国际化问题

这里主要是在设备端和b端需要做国际化，使用的插件是i18n，其中遇到的问题有：

1. 文案的key值在法语中是被多个地方使用，但是当换成德语，会出现key值不一样的问题，需要在代码中修改，维护性差
2. 解决方案：所有文案全部独立，原先是个二维数组，现在变成三位数组：文件名.文案key值
3. 在设备端，文案是存储在本地的一个json中，当修改文案，每次都需要重新打包，再部署，过程很繁琐
4. 解决方案：使用[nocodb](https://github.com/nocodb/nocodb)这个开源的sass，搭建了一套线上的翻译excel，可以通过接口获得翻译后的json文件

# 大量重复性的代码

因为很多产品的功能性在大多数都是一致的，以前的开发者会在gitee上面把一个产品的代码复制粘贴一份，迁移到另外一个产品线，然后在这个基础上进行开发

# 造成的问题

1. 因为包含多个产品，当其中一个产品要增加新功能的时候，其他产品也得同步，造成了大量的重复劳动，可维护性很差
2. 当其中一个产品出现bug，那么其他几个产品也需要进行修改

### 解决办法

1. 因为前端是缺乏私有npm组件的，所以我搭建了私有npm仓库，将公共组件进行抽离，例如table，设备详情页面，还有包括设备端的开机页面，关机页面等......
2. 后来衍生，发现npm已经无法解决管理多个产品线的问题，这里通过引入umijs中区块这个概念，
3. 每个开发着单独开发一个区块，在主项目中通过不同的配置来完成不同的产品线
4. 所有区块放在单独的一个文件夹comps，主应用单独维护一个store，全部采用store来进行通信
5. 使用这种方式可以避免因为package中依赖包版本不同造成的兼容性问题
6. 每个区块可以单独做展示

# 对于后端nestjs做出的调整

### 接口由resultful改为graphql

一开始的接口是采用resultful进行开发，但是由于所有的接口都比较简单，都是简单的增删改查接口，并且因为大家都是全栈工程师，所以后期改用了graphql进行开发，其中的优点是，一开始就定义好所有字段，前端需要什么，就查什么，在数据表不新增字段的时候，接口无需新增字段

### **采用monorepo 模式**

因为后端是属于微服务进行开发，每个服务单独占用一个node_modules，并且服务之间有对应的依赖关系。

所以这里采用了monorepo这种模式，这样就只需要修改entity，就可以生成对应的namespace与server层代码，当然proto文件还需要添加

# 对于代码提交添加约束条件

这里包括eslint+pretter规范

其中最重要的是commit规范

### 曾经出现过的问题

每个commit随意填写，无法得知这个commit是做了什么事情，并且无法溯源

解决办法：

这里使用了git hooks做出规范调整，并且每个提交中的scope对应tapd上的id